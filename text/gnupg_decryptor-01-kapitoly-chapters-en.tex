\chapter{Indroduction}
The most popular information resource today is undoubtedly the internet. One of its key advantages is data availability. Frequently, data are stored on remote devices (commonly servers) and users can connect to these devices and access data they require. These data can contain private or secret information such as family pictures, passwords, bills or other sensitive content that need to be protected. Access to a server with this kind of sensitive information can be protected by some kind of authorization (for example login and password). But even the most secure kind of authorization is not sufficient enough to secure data from unauthorized access. For a user to obtain any type of content on a remote device, data must be transferred. In the case of the internet, data are transferred over multiple devices on which data can be accessed or even modified by a potential attacker (without the knowledge of either side of communication).

\begin{figure}[H]
    \begin{center}
        \label{img:unsecureConnection}
        \includegraphics[width=1.0\textwidth]{obrazky-figures/unsecureconnection.png}
        \caption{Example of unauthorised data access and modification during its transmission.}
    \end{center}
\end{figure}

Usage of cryptography is the most frequently used solution for this problem. Data can be encrypted during the communication or encrypted data can be stored on servers and then transferred with or without further encryptions. This thesis will use the second approach, where data are already encrypted on a remote server. Under the term of data, you can imagine usual web page including not only text, images or videos but JavaScript and CSS as well. Some elements of this page (or even whole page) can be encrypted using an symmetric cypher and different parts can be encrypted using a different key or some parts can be encrypted using multiple keys. These keys are encrypted with asymmetric cypher and they are part of encrypted content as well. The outcome of this thesis will be a web browser extension that will be able to detect encrypted content (images, videos, text, etc.) and decrypt it for a user using his available keys. With this encryption/decryption system, users can create web pages where different data can be accessible for different users without the need for authentication on a remote server.

The target platform will be GNU/Linux and broswer extensions will be implemented for Firefox browser. Data will be decrypted with the Linux command line application called gpg, that will be used not only for decryption but for key management as well.

% \chapter{Theory}
% To develop functional and sufficient software for decrypting web pages, it is necessary to understand the tools we will work with. The purpose of this chapter is to introduce you to used technology in this thesis, such as GnuPG or WebExtensions. These tools have their advantages, disadvantages, and limits.

\chapter{The GNU Privacy Guard}
The GNU Privacy Guard, also known as GnuPG or GPG, is a complete and free implementation of the OpenPGP standard as defined by RFC4880 \cite{RFC4880}. GnuPG offers encryption, decryption and signing both data and communication. It features a versatile key management system with access modules for many kinds of public key directories. Not only that GnuPG is available for both Windows and Linux, but also a wealth of applications and libraries are available. \cite{GnuPG}

Linux implementation of GnuPG is a command line tool with features for integration with other applications. Windows version of GnuPG is Gpg4win with a context menu tool, a crypto manager, and an Outlook plugin to send and receive standard PGP/MIME mails. \cite{GnuPG}

\section{OpenPGP standard}
As mentioned earlier, GnuPG is the implementation of OpenPGP standard. Most of the text from this section is taken from RFC4880 \cite{RFC4880}. OpenPGP combines symmetric--key encryption and public--key encryption to provide confidentiality. First of all, the object is encrypted using a symmetric encryption algorithm. It is worth mentioning that each symmetric key is used only once for a single object. For each object, a new key is generated as a random number. This key is bound to the message and transmitted with it. Key is protected by encryption as well -- the key is encrypted with the receiver's public key. The sequence is as follows (also described in the figure \ref{img:messageEncryption}):
\begin{enumerate}
    \item A message is created by the sender.
    \item The sending OpenPGP generates a random number to be used as a session key for this message only.
    \item The generated session key is encrypted using recipient's public key. This encrypted session key starts the message.
    \item The sending OpenPGP encrypts the message using the session key, which forms the remainder of the message. Note that the message is also usually compressed.
    \item The receiving OpenPGP decrypts the session key using the recipient's private key.
    \item The receiving OpenPGP decrypts the message using the session key. If the message was compressed, it will be decompressed.
\end{enumerate}

\begin{figure}[H]
    \begin{center}
        \label{img:messageEncryption}
        \includegraphics[width=1.0\textwidth]{obrazky-figures/messageEncryption.png}
        \caption{Schema of message encryption and decryption}
    \end{center}
\end{figure}

A symmetric key, that is used for message encryption, can be derived from a passphrase (or different kind of shared secret), or a two--stage mechanism similar to the public--key method that was described above in which a session key is itself encrypted with a symmetric algorithm keyed from a shared secret.

Authentication can be achieved using a digital signature. The digital signature uses a hash code or message digest algorithm, and a public--key signature algorithm. The sequence is as follows (also described in the figure \ref{img:messageSignature}):
\begin{enumerate}
    \item A message is created by the sender.
    \item The sending software generates a hash code of the message.
    \item The sending software generates a signature by encrypting hash code of message using the sender's private key.
    \item The binary signature is attached to the message.
    \item The receiving software keeps a copy of the message signature.
    \item The receiving software generates a new hash code for the received message and verifies it using the message's hash code obtained by decrypting signature with sender's private key.
\end{enumerate}

\begin{figure}[H]
    \begin{center}
        \label{img:messageSignature}
        \includegraphics[width=1.0\textwidth]{obrazky-figures/messageSignature.png}
        \caption{Schema of message signature}
    \end{center}
\end{figure}

Both confidentiality and signature services may be applied to the same message. First signature is created and attached to the message. Then message (including signature) is encrypted using a symmetric session key. At last, this session key is encrypted with publickey encryption and prefixed to the encrypted message.

\section{GnuPG for Linux distributions}
As described above, there is a Linux application called gpg. It is important to have this application installed and configurated otherwise implemented software in this thesis will not work correctly or will not work at all. Reason for this is a fact, that GnuPG is not only used for decryption of encrypted elements but solves problems of the key management as well. Furthermore, the gpg application can be used for encryption of web pages as well.

Installation of GnuPG may differ on different operating systems. Some GNU/Linux distribution may already come with directly installable packages. However, it worth consider installation from the source code because the version of these packages may be old. The list of different GnuPG packages, libraries, required tools, optional software, legacy versions of GnuPG or manual can be found on GNU Privacy Guard web page \cite{GnuPG}.

\subsection{Basic Key Management}
Since objects are signed using the receiver's public key and decrypted with the receiver's private key, it is clear that receiver must have this keypair. Keypair is not only needed to encrypt messages but also to sign messages. With gpg installed on user's machine, the user can generate its own private and public keys. Basic key management will be further in these steps:
\begin{enumerate}
    \item Generating a new pair of private and public key
    \item Importing and exporting of both private and public keys
\end{enumerate}

\subsection*{Generating a New Pair of Private and Public Key}
To generate keypair with gpg, the user must complete several steps. The first step is to lunch gpg application with the argument \colorbox{lightgray}{\textit{-{}-gen-key}}. To prevent problems with private key access permissions, the user can specify a directory, where keys will be stored with argument \colorbox{lightgray}{\textit{-{}-homedir}}. Detailed instructions, how to manage user access to private keys, are described in the article about GPG encrypted credentials by Fabian Lee \cite{gpgAccess}.  Next, the user is asked for a name and email address. From name and email address gpg creates a User ID. The User ID is something like a name tag for generated keypair and is also used to identify an owner of a public key.
\begin{Verbatim}[commandchars=\\\{\},codes={\catcode`$=3\catcode`_=8},samepage=true,frame=single]
\textit{xmatej52@merlin: ~\$ gpg --gen-key}
Real name: \textbf{Jiří Matějka}
E-mail address: \textbf{xmatej52@stud.fit.vutbr.cz}
You are using the 'utf-8' character set.
You selected this USER-ID:
    "Jiří Matějka <xmatej52@stud.fit.vutbr.cz>"

Change (N)ame, (E)mail, or (O)kay/(Q)uit?
\end{Verbatim}

Then the user is asked to enter a passphrase. The passphrase is used to encrypt private key so it is protected. If the passphrase is compromised, anyone who can access such private key will be able to decrypt owner's received messages or sign his messages as the owner of the private key. After the user enters the passphrase, gpg need to generate a lot of random bytes and ask the user to perform some other actions. After some time, keypair is finally generated.
\begin{Verbatim}[commandchars=\\\{\},codes={\catcode`$=3\catcode`_=8},samepage=true,frame=single]
\textbf{Enter passphrase:}
We need to generate a lot of random bytes. It is a good idea to perform
some other action (type on the keyboard, move the mouse, utilise the
disks) during the prime generation; this gives the random number
generator a better chance to gain enough entropy.

gpg: key 6C9359504F0C8F81 marked as ultimately trusted
gpg: revocation certificate stored as '/path/to/file'
public and secret key created and signed.

pub   rsa3072 2019-12-30 [SC] [expires: 2021-12-29]
      3252EA3A9A0F105E226BE7BF6C9359504F0C8F81
uid                       Jiří Matějka <xmatej52@stud.fit.vutbr.cz>
sub   rsa3072 2019-12-30 [E] [expires: 2021-12-29]
\end{Verbatim}

\subsubsection*{Importing and Exporting of Both Private and Public Keys}
\label{text:keys-export}
Export of public keys is an essential feature but in some cases, it is required to export private key as well. GnuPG provides options for exporting both of the keys. While the export of a public key is not a problem, the export of a private key may require extra permissions (for example to run gpg via \textit{sudo}) if the logged user does not have permissions to access the private key. To see list of keys use command \colorbox{lightgray}{\textit{gpg -{}-list-public-keys}} for public keys and \colorbox{lightgray}{\textit{gpg -{}-list-secret-keys}} for private keys. 
\begin{Verbatim}[commandchars=\\\{\},codes={\catcode`$=3\catcode`_=8},samepage=true,frame=single]
\textit{xmatej52@merlin: ~\$ sudo gpg --list-secret-keys}
/path/to/dir/pubring.kbx
---------------------------------
sec   rsa3072 2019-08-11 [SC] [expires: 2021-08-10]
      346222BC9BEF6635994EF30DC7C029E805D6F30A
uid           [ultimate] test <test@test.cz>
ssb   rsa3072 2019-08-11 [E] [expires: 2021-08-10]

sec   rsa3072 2019-12-30 [SC] [expires: 2021-12-29]
      3252EA3A9A0F105E226BE7BF6C9359504F0C8F81
uid           [ultimate] Jiří Matějka <xmatej52@stud.fit.vutbr.cz>
ssb   rsa3072 2019-12-30 [E] [expires: 2021-12-29]
\end{Verbatim}

The user ID is shown as \textit{uid} in the list. The user ID can be used to specify which key should be exported. Command \colorbox{lightgray}{\textit{gpg -{}-armor -{}-export uid}} will export the public key specified by \textit{uid}. To export the private key, use command \colorbox{lightgray}{\textit{gpg -{}-armor -{}-export-secret-keys uid}}. Since secret keys are encrypted, the user will be asked to enter the passphrase that was entered while generating keypair.
\begin{Verbatim}[commandchars=\\\{\},codes={\catcode`$=3\catcode`_=8},samepage=true,frame=single]
\textit{xmatej52@merlin: ~\$ gpg --armor --export xmatej52@stud.fit.vutbr.cz}
-----BEGIN PGP PUBLIC KEY BLOCK-----

mQGNBF4J/jYBDAC2xruHMLrLn2SwV7n2N5dBkjVO4Jxu//BGjHNqbylcyOOaUT7l
.....
-----END PGP PUBLIC KEY BLOCK-----
\textit{xmatej52@merlin: ~\$ sudo gpg --armor --export-secret-keys \textbackslash}
\textit{xmatej52@stud.fit.vutbr.cz}
-----BEGIN PGP PRIVATE KEY BLOCK-----

nQWGBF00HzUBDADApYD+T6kx0Lb0h0MyB1CrWRmrINqHLQqQmzLiaABDLAYqvhgB
.....
-----END PGP PRIVATE KEY BLOCK-----
\end{Verbatim}

\subsection{Encrypting, Decrypting, Signing, and Verifying Data}
GnuPG was created to provide cryptographic privacy and authentication for data communication. To achieve this goal, GnuPG implements encryption, decryption and signatures algorithms. Instruction for basic usage of these algorithms will be described in the following steps:
\begin{enumerate}
    \item Encrypting files and text
    \item Decrypting files and text
    \item Signing data
    \item Verifying signed data
\end{enumerate}

\subsubsection*{Encrypting Files and Text}
GnuPG do not distinguish between text and binary files a both can be encrypted using same arguments -- \colorbox{lightgray}{\textit{gpg -{}-recipient uid -{}-encrypt [filename]}} (\textit{uid} specifies which public key will be used for encryption of generated session key). Regardless of the source file type, the output will be binary content. Though it is not a problem to use the binary representation of encrypted data for images, videos or other files, binary content cannot be used on web pages. To create encrypted text that can be used on web pages, specify argument \colorbox{lightgray}{\textit{-{}-armor}} as well.
\begin{Verbatim}[commandchars=\\\{\},codes={\catcode`$=3\catcode`_=8},samepage=true,frame=single]
\textit{xmatej52@merlin: ~\$ gpg --armor --recipient \textbackslash}
\textit{xmatej52@stud.fit.vutbr.cz --encrypt}
\textbf{Hello world}
-----BEGIN PGP MESSAGE-----

hQGMA9uyf/0+dawwAQwAgUvSRPDKKtBcVUMOU4Wna/UCaVARIQwlfQUm7hFJa1xp
.....
-----END PGP MESSAGE-----
\end{Verbatim}
\subsubsection*{Decrypting Files and Text}
Data are encrypted with a symmetric algorithm. A session key used for encryption is randomly generated and is encrypted using the receiver's public key. To decrypt the session key, it is necessary to access the receiver's private key. Because of it, decryption may require extra permissions (for example to run gpg via \textit{sudo}) if the logged user does not have permissions to access the private key. To decrypt data, run command \colorbox{lightgray}{\textit{gpg -{}-decrypt [filename]}}. If the private key is encrypted, the user will be asked to enter a passphrase.
\begin{Verbatim}[commandchars=\\\{\},codes={\catcode`$=3\catcode`_=8},samepage=true,frame=single]
\textit{xmatej52@merlin: ~\$ sudo gpg --decrypt}
\textbf{-----BEGIN PGP MESSAGE-----}

\textbf{hQGMA9uyf/0+dawwAQwAgUvSRPDKKtBcVUMOU4Wna/UCaVARIQwlfQUm7hFJa1xp}
\textbf{.....}
\textbf{-----END PGP MESSAGE-----}
\textbf{Enter passphrase:}
gpg: encrypted with 3072-bit RSA key, ID DBB27FFD3E75A, created 2019...
      "Jiří Matějka <xmatej52@stud.fit.vutbr.cz>"
Hello world
\end{Verbatim}

\subsubsection*{Signing Data}
Data are signed using the sender's private key so it is guaranteed that the sender is the only one, who can create such data (unless private key is compromised). As a result of using the private key, signing may require extra permissions if logged is not unauthorized to access the private key. Data can be signed using command \colorbox{lightgray}{\textit{gpg -{}-sign --local-user uid [filename]}} (\textit{uid} specifies which private key will be used for signing). To prevent binary content on output, argument \colorbox{lightgray}{\textit{-{}-armor}} can be specified as well. If the private key is encrypted, the user will be prompted for the passphrase he used when generating his gpg keypair.
\begin{Verbatim}[commandchars=\\\{\},codes={\catcode`$=3\catcode`_=8},samepage=true,frame=single]
\textit{xmatej52@merlin: ~\$ gpg --armor --recipient \textbackslash}
\textit{xmatej52@stud.fit.vutbr.cz --encrypt}
\textbf{Hello world}
\textbf{Enter passphrase:}
-----BEGIN PGP MESSAGE-----

owEB9QEK/pANAwAKAT3XKsKGzorWAcsSYgBeEPJkSGVsbG8gd29ybGQKiQHPBAAB
.....
-----END PGP MESSAGE-----
\end{Verbatim}

\subsubsection*{Verifing Signed Data}
Given signed data, the user can both verify the signature and recover original data. If user only wishes to check signature, he can use \colorbox{lightgray}{\textit{-{}-verify}} option. To verify the signature and extract the original data, user can use \colorbox{lightgray}{\textit{-{}-decrypt}} argument. To verify the signature, gpg need to access the sender's public key. Without the access, the original data can be still recovered but cannot be verified.
\begin{Verbatim}[commandchars=\\\{\},codes={\catcode`$=3\catcode`_=8},samepage=true,frame=single]
\textit{xmatej52@merlin: ~\$ gpg --verify}
\textbf{-----BEGIN PGP MESSAGE-----}

\textbf{owEB9QEK/pANAwAKAT3XKsKGzorWAcsSYgBeEPJkSGVsbG8gd29ybGQKiQHPBAAB}
\textbf{.....}
\textbf{-----END PGP MESSAGE-----}
gpg: Signature made Sat 04 Jan 2020 21:15:37 CET
gpg:            using RSA key 3252EA3A9A0F105E226BE7BF6C9359504F0C8F81
gpg:            issuer "xmatej52@stud.fit.vutbr.cz"
gpg: Good signature from "Jiří Matějka <xmatej52@stud.fit.vutbr.cz>"
[ultimate]
\textit{xmatej52@merlin: ~\$ gpg --decrypt}
\textit{xmatej52@merlin: ~\$ gpg --verify}
\textbf{-----BEGIN PGP MESSAGE-----}

\textbf{owEB9QEK/pANAwAKAT3XKsKGzorWAcsSYgBeEPJkSGVsbG8gd29ybGQKiQHPBAAB}
\textbf{.....}
\textbf{-----END PGP MESSAGE-----}
Hello world
gpg: Signature made Sat 04 Jan 2020 21:15:37 CET
gpg:            using RSA key 3252EA3A9A0F105E226BE7BF6C9359504F0C8F81
gpg:            issuer "xmatej52@stud.fit.vutbr.cz"
gpg: Good signature from "Jiří Matějka <xmatej52@stud.fit.vutbr.cz>"
\end{Verbatim}
\subsection{User Interface}
KGpg is KDE's application providing a simple interface for GnuPG. The application can help to set up and manage keys, import and export keys, view key signatures, trust status, expiry dates or encrypt/decrypt text or files. KGpg is a free and open source software, available for Linux and similar operating systems. Since KGpg provides user interface, KGpg makes it easy to work with the gpg command--line application so that user does not remember all the gpg's commands, particularly those for key management and data encryption/decryption. \cite{KGpg}

\section{Alternative software}
Although GnuPG is a very popular software and one of the most used implementations of OpenPGP standard implementation, there are some alternatives for GnuPG that also implements OpenPGP standard. OpenPGP.js is one of such alternatives and was even used in this thesis for prototype development.

\subsection*{OpenPGP.js}
\label{text:openpgpjs}
OpenPGP.js is a project that aims to provide an Open Source OpenPGP JavaScript library so it can be used on most of the devices. While many other implementations of OpenPGP standard are aimed at using native code, OpenPGP.js is meant to bypass this requirement so people are not forced to install gpg on their machines in order to use the library. The idea behind OpenPGP.js is to implement all the needed OpenPGP functionality in JavaScript library that can be reused in other projects that provides web browser extensions or server applications. \cite{OpenPGPjs}

OpenPGP.js library was used for the implementation of the first prototype (Section \ref{prototype:OpenPGPjs}). Implemented prototype was able to encrypt and decrypt elements using hardcoded private and public keys in the source code. Accessing the user's public and private keys was a serious problem.  When background script and native application were developed, this library was no longer necessary and was replaced with gpg (using gpg also solved the problem with private and public key access).

\chapter{WebExtensions API}
Broswer extensions are software programs that extend or modify the capabilities of a browser. They enable users to tailor web browser functionality and behaviour to individual needs or preferences. They are built on web technologies such as HTML, JavaScript, and CSS. Browser extension developed in this thesis is built using the WebExtensions API. \cite{chromeExtensions}

Extensions for Firefox are built using the WebExtensions API. It is a cross--browser system for developing extensions. To a large extent, the system of WebExtensions API is compatible with the extension API supported by Google Chrome, Opera and the W3C Draft Community Group. \cite{firefoxExtensions}

Extensions cat take advantage of the same web APIs as JavaScript on a web page, but they can access to its own set of JavaScript APIs. Thanks to this extensions can do a lot more than a developer can with code in a web page. \cite{firefoxAboutExtensios}

An extension must serve a single purpose that is narrowly defined and easy to understand. A single extension can include multiple components and a range of functionality, as long as everything contributes towards the defined purpose. \cite{chromeExtensions}

\section{Struture of an Firefox Extension}
An extension consists of a collection of files, libraries, packages and installation, yet there is the only file that must be present in every extension -- \textit{manifest.json}. The manifest contains basic metadata about the extension (name, version or the permissions it requires). It also provides a list of other files that are included in the extension. \cite{extensionAnatomy}

The manifest can also include pointers to several other types of files:
\begin{enumerate}
    \item Icons
    \item Content scripts
    \item Background scripts
    \item Sidebars, popups, and option pages
    \item Web--accessible resources
\end{enumerate}    
\begin{figure}[H]
    \begin{center}
        \label{img:extensionAnatomy}
        \includegraphics[width=1.0\textwidth]{obrazky-figures/webextension-anatomy.png}
        \caption{Anatomy of a broswer extension \cite{extensionAnatomy}.}
    \end{center}
\end{figure}

\subsection{Icons}
Icons are used to represent extension in components (for example in Add-ons Manager). Icons are represented in the manifest file as an object that consists of key--value pairs of image size (in px) and image path relative to the root directory of the extension. \cite{extensionIcnos}

It is recommended by Mozilla developers to supply at least the main extension icon, ideally in 48$\times$48\,px in size. However, it is possible to provide icons of any size and Firefox will attempt to select the best icon to display in different situations. Firefox also promises to consider screen resolution when choosing an icon so it is good practice to provide double--sized versions of all icons in order to deliver the best visual experience. \cite{extensionIcnos}

Firefox also supports the usage of icons in SVG format but it is necessary to specify \textit{viewBox} and even developer can use one file as an icon, he needs to specify various sizes of the icon in the manifest. \cite{extensionIcnos}

\subsection{Content Scripts}
Content scripts are used to access and manipulate the content of web pages. The content script is executed in the context of a particular web page and just like the scripts loaded by the web page, a content script can access DOM APIs as well.

Content scripts can only access a relatively small subset of the WebExtension API, but they can communicate with background scripts (Section \ref{text:backgroundScripts}) using a messaging system, thereby indirectly access the WebExtensions API.

\subsubsection*{Content Script Enviroment}
As mentioned earlier, content scripts can access DOM APIs therefore they are able to modify and to access DOM just like normal page scripts can. They can furthermore detect and see any changes that were made to the DOM by page scripts. However, it is worth mentioning that content script does not share JavaScript variables defined by page scripts and if page script redefines a built--in DOM property, the content script will be able only to access the original version of the modified property. The same is true in reverse -- page scripts cannot see JavaScript property changes made by the content script. \cite{extensionContentScripts}

Another feature content scrips have is the possibility of making requests using \textit{window.XMLHttpRequest} and \textit{window.fetch()} APIs. Content script shares the same cross--domain privileges with the rest of the extension. So in case the extension has requested cross--domain access for domain using the permissions key in the manifest file, then its content script can get access to the same domain as well. \cite{extensionContentScripts}

Possibility of communication with background scripts (Section \ref{text:backgroundScripts}) is another important feature of content scripts. There are two basic types of communication between the content and background scripts -- one--of messages and longer--lived connection. One--off messaging is useful when none or only one response is expected to a message and when only a small number of scripts listen to receive messages. On the other hand, it is recommended to use connection-based messaging where multiple messages are exchanged or where the extension need information about task progress, needs to be notified if a task is interrupted, or may want to interrupt a task initiated using messaging. \cite{extensionContentScripts}

\subsection{Background Scripts}
\label{text:backgroundScripts}
Background scripts are for mainntaining long--term state or for performing long--term operations independently of the lifetime of any particular web page or broswer window. Background scripts loaded with extention installation and stay loaded until the extention is disabled or uninstalled. Developers can also profit from WebExtension APIs in background scripts, although it is necessary to specify any needed permissions in the manifest file. \cite{extensionAnatomy}

Background page is special page that provides a \textit{window} global, along with all the standard DOM APIs provided by it. Since background scripts run in context of the background page, they can access the the \textit{window} global. \cite{extensionAnatomy}

Background scripts does not have direct access to web pages. But they are alowed to load content scripts into web pages and they can communicate with these scripts. \cite{extensionAnatomy}
\subsection{Sidebars, Popups, and Option Pages}
Extensions can include various user interface components. Those components are defined with an HTML document. Components can be:
\begin{enumerate}
    \item Sidebar -- a pane displayed at the side of the browser window, next to the web page
    \item Popup -- a dialogue that is associated with a toolbar button or address bar button
    \item Option page -- a page that enables preferences that user can change
\end{enumerate}

Every component is defined with its own HTML document and a point to it using specific property in the manifest file. Such HTML document can include both CSS and JavaScript files. JavaScript can use all privileged WebExtension APIs as background scripts (Section \ref{text:backgroundScripts}) and they can even directly access variables in the background page using a special method \textit{runtime.getBackgroundPage()}. \cite{extensionAnatomy}

\subsection{Web--Accessible Resources}
Sometimes it is needed to provide resources (images, HTML, CSS, JavaScript, etc.) and make them available to web pages. This problem is solved with web--accessible resources. Resources which are made web--accessible can be referenced by page scripts and content scripts using special URI scheme. \cite{extensionAnatomy}

Note that if a page is made web--accessible, any website may link or redirect to that page. Therefore web--accessible pages should treat any input as if it came from an untrusted source. \cite{extensionWebAccessibleResources}

\subsection{Extension Pages}
Extension pages are HTML documents in broswer extention that are not attached to some predefined user interface components. Extension pages do not have entry in the manifest file unlike sidebars, popups, or option pages. However, they also get access to the same privileged WebExtension APIs as your background script. \cite{extensionAnatomy}

\section{Native Applications}
A native application is installed using the underlying operating system's installation machinery. A browser can communicate with the native application via a native messaging mechanism. This enables an extension to exchange messages with the native application installed on the user's computer. Thanks to this mechanism, native applications can provide services to extensions without needing to be reachable over the web. Another feature provided by the native application is that they can enable to access resources that are not accessible through WebExtension APIs, such as hardware. \cite{extensionNativeMessaging}

Along with the native application itself, the developer needs to provide another manifest file called "host manifest" or "app manifest" and install it in a defined location on the user's computer. The host manifest file describes how the browser can connect to the native application. Note, that the extension must also request permission "nativeMessaging" in its manifest file and the native application must include the extension's ID in the "allowed\_extensions" field of the host manifest. \cite{extensionNativeMessaging}

Once both extension manifest and host manifest are correctly set, the extension can exchange messages in JSON format with the native application. The native application receives messages on its standard input and sends them using its standard output. The extension uses a set of functions of the runtime API. \cite{extensionNativeMessaging}

\begin{figure}[H]
    \begin{center}
        \label{img:extensionAnatomy}
        \includegraphics[width=1.0\textwidth]{obrazky-figures/native-messaging.png}
        \caption{Native messaging scheme \cite{extensionNativeMessaging}.}
    \end{center}
\end{figure}

\chapter{Implementation}
The goal of this thesis is to implement a browser extension that will detect encrypted elements on a web page and decrypt them. Developing software is a complex and demanding process and it is not easy to deliver a project that correspondents with stakeholder's expectation. To fulfil all expectation, this thesis will be developed in several iterations.

Each iteration will consist of design, development, testing and review. The iteration will be usually 2 -- 3 weeks long and will result in a prototype. The prototype will be then disgusted with thesis supervisor -- Ing. Libor Polčák, Ph.D.

\begin{figure}[H]
    \begin{center}
        \label{img:extensionAnatomy}
        \includegraphics[width=1.0\textwidth]{obrazky-figures/developementModel.png}
        \caption{Software development model.}
    \end{center}
\end{figure}

\section{OpenPGP.js Prototype}
\label{prototype:OpenPGPjs}
Purpose of the first prototype was in case of this thesis to learn how to develop browser extension. The goal was to implement a simple browser extension that will be able to decrypt image using a hardcoded private key. Ideal library for this task was OpenPGP.js (Section \ref{text:openpgpjs}) and since Firefox browser had troubles to load this library, this prototype was implemented for Google Chrome browser.

\subsection{Design}
No background script or native application was needed to develop the background script so new script -- called \textit{gnupg\_decryptor.js} and OpenPGP.js library can be loaded as content scripts. Designated schema of web extention can be seen in the figure \ref{img:openpgpAnatomy}. Script \textit{gnupg\_decryptor.js} will detect encrypted image by file suffix in its source URL, downloads it, and tries to decrypt it using OpenPGP.js library. Once the content is decrypted, \textit{gnupg\_decryptor.js} will create a new URL pointing to the decrypted image and replace the source URL of \textit{img} element on web page thus displaying the decrypted image to a user. Icon, that represents the extension, was taken from The GNU Privacy Guard \cite{GnuPG}.

\begin{figure}[H]
    \begin{center}
        \label{img:openpgpAnatomy}
        \includegraphics[width=1.0\textwidth]{obrazky-figures/prototype-openpgpjs.png}
        \caption{Structure of the OpenPGP.js prototype.}
    \end{center}
\end{figure}

\subsection{Implementation}
Since some parts of this prototype will serve as the foundation stone for next development, special care was taken for reusability of useful functions as well as preparing testing web pages, a different set of encrypted data and also to prepare special scenarios, specifically another web extension that changes DOM of a web page. Simplified schema of the implemented prototype can be seen on the figure \ref{img:openpgp-sequence} (Note that schema does not show communication between objects, as usually sequence diagram does, but it shows communication between content scripts).
\begin{figure}[H]
    \begin{center}
        \label{img:openpgp-sequence}
        \includegraphics[width=1.0\textwidth]{obrazky-figures/openpgp-sequence.png}
        \caption{Communication between content scripts of OpenPGP.js prototype.}
    \end{center}
\end{figure}


\subsection{Review}
The implemented prototype was able to detect images on web page by their source URL and then decrypt them using the OpenPGPjs library. Prototype was able to use only hardcoded keys and could not access user's keyring on his computer. Prototype did not need any background scripts nor native application. The only broswer where was implemented extention operational was Google Chrome.

Some functions implemented in this prototype will be included in future prototypes and maybe in final product of this thesis. The main benefit from first iteration were implemented test pages, encrypted images, generated keypairs and experience with web extention developement.

\section{GnuPG\_Decryptor Prototype}
\label{prototype:GnuPG_Decryptor}
Hardcoded keys were one of the biggest problems of the previous prototype. A new prototype should have access to users keyring. In order to access it, it will be necessary to implement a native application that will be able to communicate with gpg application. With the native application, OpenPGP.js library will no longer be necessary and all decryption tasks will handle gpg itself.

\subsection{Design}
Content script (\textit{gnupg\_decryptor.js}) will start the communication with background script. Background script will serve only as an intermediator and will resend messages from content script to the native application. The native application will be implemented in Python language and will communicate with gpg using \textit{subprocess} library. Since user must provide passphrase to private key, native application will have user interface as well. User interface will be implemented using \textit{tkinter} library. All used Python libraries are showned on the figure \ref{img:gnupg_decryptorAnatomy}.

\begin{figure}[H]
    \begin{center}
        \label{img:gnupg_decryptorAnatomy}
        \includegraphics[width=1.0\textwidth]{obrazky-figures/prototype-GnuPG_Decryptor.png}
        \caption{Anatomy of the GnuPG\_Decryptor prototype.}
    \end{center}
\end{figure}

Decoded content will be sent to background script and it will resend it to content script. The content script will then replace encrypted data with decrypted data the same way as in OpenPGP.js prototype (Section \ref{prototype:OpenPGPjs}).

Messages must be in JSON format. All messages will have a mandatory field \textit{type} that will describe the type of message. In this prototype, supported types will be \textit{decryptResponse, decryptRequest, and debug}. A message with type \textit{decryptRequest} will have mandatory fields \textit{messageId} containing the ID of an encrypted element on a web page, \textit{data} containing encrypted data, and \textit{encoding} specifying which encoding was used to encode the content of field \textit{data}. A message of type \textit{decryptResponse} will have mandatory fields \textit{success} specifing if the decryption was successful, \textit{data} containing base64 string with decrypted content (or an empty string if failed),  \textit{message} containing an error message if decryption failed (or an empty string on success), and \textit{messageId} containing the ID of \textit{decryptRequest} message to which the response relates.

\subsection{Implementation}
Purpose of this prototype was the implementation of a messaging system that will be used in future development. The messaging system simplifies debugging of a native application by supporting debug messages and the system is extensible and reusable although the system is still incomplete.

The native application was implemented as simple as possible. Application has two dialogues to enter the passwords -- password for sudo to access user's keyring and for a passphrase to decrypt the private key. The application does support decryption using only one encrypted key and does not resolve errors reported by sudo or gpg itself. Simplified schema of the implemented prototype can be seen on the figure \ref{img:gnupg_decryptor-sequence} (Note that schema does not show communication between objects, as usually sequence diagram does, but it shows communication between content script, background script, native application and GnuPG application).

\begin{figure}[H]
    \begin{center}
        \label{img:gnupg_decryptor-sequence}
        \includegraphics[width=1.0\textwidth]{obrazky-figures/sequence-gnupg_decryptor.png}
        \caption{Communication between web extension, native application, and GnuPG application.}
    \end{center}
\end{figure}

\subsection{Review}
The implemented prototype can access to a certain extent user's keyring. Using a messaging system, the extension is able to exchange data between gpg application installed on the user's computer and web browser thus enabling usage of gpg for decryption. Through messaging system is incomplete, the GnuPG\_Decryptor prototype offers sufficient basis for future development.

Future prototypes must complete messaging system -- there is missing functionality dealing with the limited size of messages and maximum size of exchanged content. The user interface provided by the native application is also insufficient and must be improved in order to use multiple keys for decryption and do not require sudo password if not necessary. The native application also needs to deal with errors occurs during data decryption and somehow informs the user about the error.

\section{Future Development}
The anatomy of the web browser extension will only differ slightly from the anatomy of the GnuPG\_Decryptor prototype (Figure \ref{img:gnupg_decryptorAnatomy}). Only icons and used Python libraries will be changed. But bigger changes are expected in these areas:
\begin{itemize}
    \item Messaging system
    \item Native application
    \item Content script
\end{itemize}

\subsection{Messaging System}
The messaging system will be extended to support the limited size of a single message (1\,MB) and maximum size of transmitted content (4\,GB) between the native application and the background script. It is also expected that new types of messages will be created.

To ensure that maximum size of transmitted content will not be exceeded, both the native application and the background script will be responsible to keep information about the size of transmitted content and when they reach critical value, they inform each other that it is needed to re-establish a new connection.

To support the limited size of a single message, all types of messages will have mandatory elements \textit{messageId} and \textit{lastBlock}. If a message would exceed the maximum size, its data will be split into blocks and each block will be sent with separately with the same \textit{messageId}. The field \textit{lastBlock} will be set to value 1 in case of the last block otherwise to 0.

\subsection{Native application}
The native application must be able to handle any error occurred during a data decryption process, usage of sudo, incorrect passphrase entry, etc. The native application will also implement the user interface.

The user interface will support multiple password entries for different private keys. Providing sudo password will not be mandatory anymore since a user might not have permission to use it. Draft of a simple sufficient user interface is shown on the figure \ref{img:userInterfaceDesign}.

\begin{figure}[H]
    \begin{center}
        \label{img:userInterfaceDesign}
        \includegraphics[width=1.0\textwidth]{obrazky-figures/UI-design.png}
        \caption{Draft of a possible user interface.}
    \end{center}
\end{figure}

\subsection{Content Script}
Currently, the content script can only detect encrypted images. Detection of other encrypted elements (text, videos, div backgrounds, etc.) must be implemented. It is also necessary to detect any changes on a web page (for example received data by XHR API, Fetch API, or Push
API).

Encrypted files (images, videos, etc.) will be detected by file suffixes \textit{.gpg} and \textit{.asc}. The encrypted text will be detected by "armoured" text prefix:
\begin{verbatim}
-----BEGIN PGP MESSAGE-----
\end{verbatim}

Changes on web pages will be detected using \textit{MutationObserver} interface. With this interface, it will be possible to detect any changes made to the DOM tree.

\chapter{Conclusion} 
Last implemented prototype is able to use GnuPG application to decrypt encrypted data and to access user's keyring. Yet there are still many things to improve. Current prototype lacks abilities to detect all of the encrypted elements on a web page, to detect any changes in DOM tree, to access and use multiple private keys for data encryption. Provided user interface demands sudo password and passphrase to decrypt private key, the native application is unable to handle any errors.

Individual deficiencies will be fixed or implemented in one of the future prototypes. With every prototype implemented, this thesis will be closer to completion. Since most of the current problems have designated solutions, nothing prevent further development.